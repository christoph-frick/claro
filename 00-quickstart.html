<!DOCTYPE html PUBLIC ""
    "">
<html><head><meta charset="UTF-8" /><script src="js/highlight.min.js" type="text/javascript"></script><script>hljs.initHighlightingOnLoad();</script><title>Basics</title><link rel="stylesheet" type="text/css" href="css/default.css" /><link rel="stylesheet" type="text/css" href="css/solarized-light.css" /><script type="text/javascript" src="js/jquery.min.js"></script><script type="text/javascript" src="js/page_effects.js"></script></head><body><div id="header"><h2>Generated by <a href="https://github.com/weavejester/codox">Codox</a> with <a href="https://github.com/xsc/codox-theme-rdash">RDash UI</a> theme</h2><h1><a href="index.html"><span class="project-title"><span class="project-name">claro</span> <span class="project-version">0.2.0-SNAPSHOT</span></span></a></h1></div><div class="sidebar primary"><h3 class="no-link"><span class="inner">Project</span></h3><ul class="index-link"><li class="depth-1 "><a href="index.html"><div class="inner">Index</div></a></li></ul><h3 class="no-link"><span class="inner">Topics</span></h3><ul><li class="depth-1 "><a href="00-basics.html"><div class="inner"><span>Basics</span></div></a></li><li class="depth-1  current"><a href="00-quickstart.html"><div class="inner"><span>Basics</span></div></a></li></ul><h3 class="no-link"><span class="inner">Namespaces</span></h3><ul><li class="depth-1"><div class="no-link"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>claro</span></div></div></li><li class="depth-2"><a href="claro.data.html"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>data</span></div></a></li><li class="depth-3"><a href="claro.data.ops.html"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>ops</span></div></a></li><li class="depth-2"><a href="claro.engine.html"><div class="inner"><span class="tree" style="top: -52px;"><span class="top" style="height: 61px;"></span><span class="bottom"></span></span><span>engine</span></div></a></li><li class="depth-3"><a href="claro.engine.adapter.html"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>adapter</span></div></a></li><li class="depth-2"><a href="claro.projection.html"><div class="inner"><span class="tree" style="top: -52px;"><span class="top" style="height: 61px;"></span><span class="bottom"></span></span><span>projection</span></div></a></li></ul></div><div class="document" id="content"><div class="doc"><div class="markdown"><h1><a href="#basics" name="basics"></a>Basics</h1>
<p>claro is a library that allows you to streamline your data access, providing powerful optimisations and abstractions along the way.</p>
<pre><code class="clojure">(require '[claro.data :as data]
         '[claro.engine :as engine]
         '[claro.projection :as projection]
         '[manifold.deferred :as d])
</code></pre>
<h3><a href="#resolvables" name="resolvables"></a>Resolvables</h3>
<p>We define our data access as records implementing the <code>Resolvable</code> protocol.</p>
<pre><code class="clojure">(defrecord Person [id]
  data/Resolvable
  (resolve! [_ env]
    (d/future
      (fetch-person! (:db env) id))))
</code></pre>
<blockquote>
  <p><strong>Note:</strong> You won’t be able to use <code>extend-type</code>/<code>extend-protocol</code> with <code>Resolvable</code> – claro won’t pick those values up since (for performance reasons) it checks for the <em>interface</em>, not the protocol.</p>
</blockquote>
<p>Now, we can create an instance of our resolvable and retrieve the respective value:</p>
<pre><code class="clojure">(engine/run!! (-&gt;Person 1))
;; =&gt; {:id 1, :name "Sherlock Holmes"}
</code></pre>
<p>But Resolvables don’t have to be top-level values, they can be anywhere within a nested structure:</p>
<pre><code class="clojure">(engine/run!! {:sherlock (-&gt;Person 1), :watson (-&gt;Person 2)})
;; =&gt; {:sherlock {:id 1, :name "Sherlock Holmes"}
;;     :watson   {:id 2, :name "John Watson"}}
</code></pre>
<p>And this way you can even write resolvables that produce other resolvables:</p>
<pre><code class="clojure">(defrecord FriendsOf [id]
  data/Resolvable
  (resolve! [_ env]
    (d/future
      (-&gt;&gt; (fetch-friend-ids! (:db env) id)
           (map -&gt;Person)))))
</code></pre>
<blockquote>
  <p><strong>Note:</strong> <code>d/future</code> creates a Manifold future but you can use any deferred value, e.g. Clojure futures or the result of <code>ExecutorService.submit()</code>.</p>
</blockquote>
<h3><a href="#batching" name="batching"></a>Batching</h3>
<p>With our above records, resolving a <code>FriendsOf</code> record for someone that has a hundred friends will produce a hundred <code>Person</code> queries. This is usually both unwanted and unnecessary since data access can be batched.</p>
<p>You can tell claro that there is such a batchwise resolution logic by additionally implementing the <code>BatchedResolvable</code> protocol:</p>
<pre><code class="clojure">(defrecord Person [id]
  data/Resolvable
  data/BatchedResolvable
  (resolve-batch! [_ env people]
    (d/future
      (fetch-people! (:db env) (map :id people)))))
</code></pre>
<blockquote>
  <p><strong>Note:</strong> Don’t forget to also implement <code>Resolvable</code> – this is after all what claro takes to identify values of interest.</p>
</blockquote>
<p><code>resolve-batch!</code> gets a seq of all values to resolve (including the current one) as its third parameter. It has to return results in an order matching the input, e.g. the result seqs first element is the resolved value for the first resolvable, and so on.</p>
<h3><a href="#mutations" name="mutations"></a>Mutations</h3>
<p>Nothing prevents you from performing side-effects in <code>resolve!</code> or <code>resolve-batch!</code> but letting them run wild can produce unexpected results. This is why you should always mark them with the <code>Mutation</code> protocol:</p>
<pre><code class="clojure">(defrecord IncrementBy [n]
  data/Mutation
  data/Resolvable
  (resolve! [_ {:keys [counter]}]
    (swap! counter + n)))
</code></pre>
<p>claro imposes some healthy restrictions on mutations:</p>
<ul>
  <li>They can only be used at the top-level, i.e. they cannot be returned from  <code>resolve!</code> or <code>resolve-batch!</code>.</li>
  <li>There can only be one mutation per call to <code>engine/run!!</code> – execution order is  a responsibility of the caller.</li>
  <li>If mutations and normal resolvables are mixed, the mutation will be run before  any other values.</li>
</ul></div></div></div></body></html>